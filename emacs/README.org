# -*- lexical-binding:t; -*-
#+startup: fold
#+startup: hideblocks
#+property: header-args:elisp :results silent :lexical t

* Emacs configuration
* Constants
** Directories
#+begin_src elisp
  (defconst sr/dotfiles-directory (expand-file-name "~/me/dotfiles")
    "Root directory for dotfiles.")

  (defconst sr/emacs-load-directory
    (file-name-concat sr/dotfiles-directory "emacs/lisp")
    "Directory for personal lisp libraries.")

  (defconst sr/note-root-directory (expand-file-name "~/me/myself/")
    "Root directory for notes.")

  (defconst sr/note-periodic-directory
    (file-name-concat sr/note-root-directory "life/")
    "Directory for periodic notes.")

  (defconst sr/note-project-directory
    (file-name-concat sr/note-root-directory "projects/")
    "Directory for project notes.")

  (defconst sr/note-second-brain-directory
    (file-name-concat sr/note-root-directory "second-brain/")
    "Directory for second bran.")

  (defconst sr/note-zk-directory
    (file-name-concat sr/note-root-directory "zk/")
    "Directory for Zettelkasten.")

  (defconst sr/note-media-directory
    (file-name-concat sr/note-root-directory "media/")
    "Directory for media (e.g. images)")

  (defconst sr/dev-project-directory
    "~/me/ws/projects/"
    "Directory for software projects")
#+end_src
** Files
#+begin_src elisp
  (defconst sr/readme-org-file-name
    (expand-file-name "emacs/README.org" sr/dotfiles-directory)
    "File name for README.org configuration file.")
#+end_src
* Load
#+begin_src elisp
  (add-to-list 'load-path sr/emacs-load-directory)
#+end_src

Small enhancement packages are not loaded here
#+begin_src elisp
  (require 'auctex)
  (require 'cc-mode)
  (require 'cdlatex)
  (require 'corfu)
  (require 'consult)
  (require 'eglot-booster)
  (require 'elfeed)
  (require 'flymake)
  (require 'format-all)
  (require 'magit)
  (require 'markdown-mode)
  (require 'modus-themes)
  (require 'org)
  (require 'org-agenda)
  (require 'org-bookmark-heading)
  (require 'org-capture)
  (require 'org-journal)
  (require 'org-ql)
  (require 'org-social)
  (require 'org-super-agenda)
  (require 'rainbow-mode)
  (require 'rfc-mode)
  (require 'rg)
  (require 'vertico)
  (require 'vterm)
#+end_src

Personal libraries
#+begin_src elisp
  (require 'sr-startup)
#+end_src
* Package management
** Use Melpa
#+begin_src elisp
  (add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
#+end_src
** Setup Custom
#+begin_src elisp
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)
#+end_src
* Environment
These are ad-hoc configurations for my local environment.
** Workaround: =Invalid function: org-element-with-disabled-cache=
[[https://www.reddit.com/r/emacs/comments/1hayavx/invalid_function_orgelementwithdisabledcache/][Reddit]]
#+begin_src elisp
  (setq native-comp-jit-compilation-deny-list '(".*org-element.*"))
  (load-library "org-element.el")
#+end_src
** mise integration
[[https://mise.jdx.dev/ide-integration.html#emacs][IDE integration with mise]]
#+begin_src elisp
  (setenv "PATH" (concat (getenv "PATH") ":/home/user/.local/share/mise/shims"))
  (setq exec-path (append exec-path '("/home/user/.local/share/mise/shims")))
#+end_src
** exec-path-from-shell
#+begin_src elisp
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+end_src
** macOS keyboard
#+begin_src elisp
  (setq mac-option-modifier 'meta)
#+end_src
* Enable disabled commands
#+begin_src elisp
(put 'scroll-left 'disabled nil)
#+end_src
* Repeated key bindings
From [[https://karthinks.com/software/persistent-prefix-keymaps-in-emacs/][Persistent prefifx keymaps in Emacs]]
#+begin_src elisp
  (defun sr/repeated-prefix-help-command ()
    (interactive)
    (when-let* ((keys (this-command-keys-vector))
                (prefix (seq-take keys (1- (length keys))))
                (orig-keymap (key-binding prefix t))
                (keymap (copy-keymap orig-keymap)))
      (setq sr/transient-map--exit-func (set-transient-map keymap t nil "Repeating"))
      (define-key keymap [remap keyboard-quit]
        		  (lambda ()
        		    (interactive)
        		    (funcall sr/transient-map--exit-func)))
      (keymap-set keymap "C-h"
  		(lambda ()
  		  (interactive)
  		  (funcall sr/transient-map--exit-func)
  		  (describe-bindings prefix)))))

  (setq prefix-help-command #'sr/repeated-prefix-help-command)
#+end_src
* Use short answers
#+begin_src elisp
  (setq use-short-answers t)
#+end_src
* UI and Display
** Remove bars
#+begin_src elisp
  (menu-bar-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
#+end_src
** Set transparent title bars
#+begin_src elisp
  (set-frame-parameter nil 'ns-transparent-toolbar t)
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
#+end_src
** Title bar text
#+begin_src elisp
  (setq-default frame-title-format "")
#+end_src
** Font faces
*** Enable fixed windows
Before customizing fonts, temporarily enable fixed windows
to prevent resizing windows when changing fonts.
#+begin_src elisp
(setq-default window-size-fixed t)
#+end_src
*** Font faces
#+begin_src elisp
  (set-face-attribute 'default nil
  		    :height 150
  		    :family "JetBrains Mono")
  (set-face-attribute 'variable-pitch nil
  		    :height 160
  		    :family "Pretendard Variable")
#+end_src
*** Disable fixed windows
#+begin_src elisp
(setq-default window-size-fixed nil)
#+end_src
** Line height
#+begin_src elisp
(setq-default line-spacing 3)
#+end_src
* Editing
** Tab bar mode
#+begin_src elisp
  (tab-bar-mode)
  (keymap-global-set "C-c <SPC>" tab-prefix-map)
  (keymap-set tab-prefix-map "]" 'tab-next)
  (keymap-set tab-prefix-map "[" 'tab-previous)
  (setq tab-bar-auto-width-max '((140) 20))
#+end_src
** Visual line mode
#+begin_src elisp
(global-visual-line-mode)
#+end_src
*** Disable on org agenda
#+begin_src elisp
  (add-hook 'org-agenda-mode-hook
            (lambda ()
              (visual-line-mode 0)))
#+end_src
** Sentences
#+begin_src elisp
  (setq sentence-end-double-space nil)
  (setq sentence-end-base "[.?!…‽,][]\"'”’)}»›]*")
#+end_src
** Mark ring
#+begin_src elisp
(setq set-mark-command-repeat-pop t)
#+end_src
** Registers
#+begin_src elisp
  (setopt register-use-preview 'insist)
#+end_src

Key binding for =M-x append-to-register=.
#+begin_src elisp
  (keymap-set ctl-x-r-map "a" #'append-to-register)
#+end_src
** Insert quotes more easily
#+begin_src elisp
(defun sr/insert-quotes (&optional arg)
  "Like `insert-parentheses`, but for quotes."
  (interactive "P")
  (insert-pair arg ?\" ?\"))
(keymap-global-set "M-\"" 'sr/insert-quotes)
#+end_src
** Clear empty lines
#+begin_src elisp
  (defun sr/clear-empty-lines ()
    "Clear empty lines on current buffer.

  When region is activated, operat on that region."
    (interactive)
    (save-restriction
      (save-excursion
        (when (use-region-p)
          (narrow-to-region (region-beginning) (region-end)))
        (goto-char (point-min))
        (delete-matching-lines "^$"))))
#+end_src
** Delete pair
#+begin_src elisp
(setq delete-pair-blink-delay 0)
(keymap-global-set "C-M-z" 'delete-pair)
#+end_src
* Windows
[[https://karthinks.com/software/emacs-window-management-almanac][The Emacs Window Management Almanac]] is a good reference
** Display-buffer
#+begin_src elisp
  (setq switch-to-buffer-obey-display-actions t)
#+end_src
** Keymap
#+begin_src elisp
  (defvar-keymap sr/window-map
  	:doc "Keymap for window-related functionalities.")

  (keymap-set ctl-x-map "C-w" sr/window-map)

  ; Remove colliding maps
  (keymap-unset org-agenda-mode-map "C-x C-w")
#+end_src
** Swap states (windmove)
#+begin_src elisp
  (require 'windmove)
#+end_src

#+begin_src elisp
  (keymap-set sr/window-map "C-l" #'windmove-swap-states-right)
  (keymap-set sr/window-map "C-h" #'windmove-swap-states-left)
  (keymap-set sr/window-map "C-k" #'windmove-swap-states-up)
  (keymap-set sr/window-map "C-j" #'windmove-swap-states-down)
#+end_src
** Scroll other window
#+begin_src elisp
  (keymap-global-set "C-M-c" #'scroll-other-window-down)
#+end_src
** Winner mode
#+begin_src elisp
  (setq winner-dont-bind-my-keys t)
  (winner-mode)
#+end_src

#+begin_src elisp
  (keymap-set sr/window-map "<left>" #'winner-undo)
  (keymap-set sr/window-map "<right>" #'winner-redo)
#+end_src
* Buffers
** Default scratch buffer message
#+begin_src elisp
(setq initial-scratch-message "\
;; Hi this is a scratch buffer

")
#+end_src
** Short for switching previous/next buffer
#+begin_src elisp
(keymap-global-set "C-c b l" 'previous-buffer)
(keymap-global-set "C-c b r" 'next-buffer)
#+end_src
** Helper function: delete current buffer's file
#+begin_src elisp
(defun sr/delete-current-file ()
  "Delete current buffer's file."
  (interactive)
  (delete-file (buffer-file-name)))
#+end_src
* Workflow
** Starting hour of a day
#+begin_src elisp
(defconst sr/note-day-start-hour 3 "The starting hour of a day for notes.")
#+end_src
** Get today for the note system
#+begin_src elisp
(defun sr/note-current-date ()
  "Return current time value for the note system. If the time is before
`sr/note-day-start-hour', return yesterday's date. Otherwise, return
today's date."
  (let* ((time (decode-time))
	 (current-day (decoded-time-day time))
	 (day (if (< (decoded-time-hour time) sr/note-day-start-hour)
		  (- current-day 1)
		current-day)))
    (encode-time (append (list 0 0 0 day) (seq-subseq time 4)))))
#+end_src
** Get file for today
#+begin_src elisp
  (defun sr/file-name-today ()
    "Return the file name for today."
    (expand-file-name
     (format-time-string "%Y-%m.org" (sr/note-current-date))
     sr/note-periodic-directory))
#+end_src
** Key map
#+begin_src elisp
  (defvar-keymap sr/workflow-map)

  (keymap-global-set "C-c j" sr/workflow-map)
#+end_src
** Open buffer for today
todo: move the point to today's entry, if needed.

#+begin_src elisp
  (defun sr/find-today-buffer ()
    "Open buffer for today's daily note."
    (interactive)
    (find-file (sr/file-name-today)))

  (keymap-set sr/workflow-map "j" #'sr/find-today-buffer)
#+end_src
** Start today
#+begin_src elisp
  (defun sr/start-today ()
    "Begin today by creating an entry to the Org buffer for today."
    (interactive)
    (find-file (sr/file-name-today))
    (goto-char (point-max))
    (unless (is-empty-line-p)
      (insert "\n"))
    (insert (concat
             "* "
             (format-time-string "%Y-%m-%d" (sr/note-current-date))))
    (recenter 0)
    (save-excursion
      (insert "\n** Logs")))

  (keymap-set sr/workflow-map "s" #'sr/start-today)
#+end_src
** Finish today
I finish each day by committing changes I made in personal files into the Git repository.

#+begin_src elisp
  (defconst sr/personal-git-repositories
    `(
      ; (,sr/dotfiles-directory . "dotfiles")
      (,sr/note-root-directory . "notes"))
    "Git repositories for personal workflow.
  Used by `sr/finish-today' for automatic daily commits.")

  (defun sr/finish-today ()
    "Finish daily workflow; save all buffers associated with a file, commit
  changes in personal repositories."
    (interactive)
    (save-some-buffers t)
    (dolist (repo sr/personal-git-repositories)
      (let ((name (cdr repo))
  	  (default-directory (car repo))
  	  (subcommands `(("add" ".")
  			 ("commit" "-m"
  			  ,(format-time-string "%Y%m%d" (sr/note-current-date)))
  			 ("push"))))
        (dolist (args subcommands)
  	(apply 'call-process (append '("git" nil nil nil) args)))
        (message (format "Commited and pushed changes in %s." name))))
    (message "Done. Good night :)"))

  (keymap-set sr/workflow-map "f" #'sr/finish-today)
#+end_src
* Migration
** Migrate inline latex
#+begin_src elisp
(defun sr/migrate-latex ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "\\$\\(.+?\\)\\$" nil t)
      (replace-match "\\\\(\\1\\\\)"))))
(keymap-global-set "C-c m l" 'sr/migrate-latex)
#+end_src
** Check if the current line is empty
Helper function for migration command
#+begin_src elisp
(defun is-empty-line-p ()
  "Return t if current line only includes whitespace, else return
nil."
  (not (not (string-match-p "^[[:blank:]]*$"
        (buffer-substring (line-beginning-position)
                          (line-end-position))))))
#+end_src
** Remove empty lines before/after headings
#+begin_src elisp
  ;; this is a quite hacky implementation; fix later
  (defun sr/org-remove-empty-lines-around-headings ()
    "Remove empty lines before and after each headings."
    (interactive)
    (org-map-entries
       (lambda ()
         (forward-line -1)
         (when (is-empty-line-p)
           (insert "##delete##"))
         (forward-line 2)
         (when (is-empty-line-p)
           (insert "##delete##")))
       nil (if (region-active-p) 'region nil))
    (delete-matching-lines "##delete##"))

  (keymap-global-set "C-c m h" 'sr/org-remove-empty-lines-around-headings)
#+end_src
** Migrate old Org mode documents
#+begin_src elisp
(defun sr/migrate-org-properties ()
  "Migrate current old Org document to follow the new format. Specifically:
- move incorrect buffer options (created and updated) into properties.
- if ZK, call `sr/set-zettel-id-property'.
- Move filetags into entry tags."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (let ((created-at (and (re-search-forward "^#\\+created: \\(.+\\)$" nil t)
			   (let ((val (match-string 1)))
			     (beginning-of-line)
			     (delete-line)
			     val)))
	  (updated-at (and (re-search-forward "^#\\+updated: \\(.+\\)$" nil t)
			   (let ((val (match-string 1)))
			     (beginning-of-line)
			     (delete-line)
			     val)))
	  (filetags (and (re-search-forward "^#\\+filetags: \\(.+\\)$" nil t)
			   (let ((val (match-string 1)))
			     (beginning-of-line)
			     (delete-line)
			     val))))
      (org-next-visible-heading 1)
      (when created-at (org-set-property "created" created-at))
      (when updated-at (org-set-property "updated" updated-at))
      (when filetags (org-set-tags (string-replace "-" "_" filetags))))
    (sr/set-zettel-id-property)))
#+end_src
** Migration from markdown
Previously, I used plain markdown documents for note taking.
Now I have to migrate from it.

I chose incremental migration. When I see a markdown note, I
explicitly call the migration command to convert to Org format. I
wanted more fine-grained control over my notes, so I needed to verify
the correctness of the conversion result.
*** Pandoc migration command
The path to the lua filter is hardcoded. This could be improved.

#+begin_src elisp
(defvar sr/pandoc-migration-command
  "pandoc --wrap=preserve -f commonmark+task_lists+yaml_metadata_block -s -t org --lua-filter=/Users/kimsaram32/me/myself/pandoc-filter.lua"
  "Command to use for `sr/migrate-to-org'.")
#+end_src
*** Convert from markdown to Org
#+begin_src elisp
  (defun sr/migrate-markdown-to-org ()
    "Convert current markdown file into Org Mode document, using Pandoc.
  Open the converted document in current buffer.
  Perform the following transformations:
  - move frontmatters (created and updated) into properties.
  - if ZK, transform links and add custom_id property.
  - if non-ZK, remove links as they are broken."
    (interactive)
    (message "Converting markdown to Org...")
    (save-excursion
      (goto-char (point-min))
      (let* ((input-buffer (current-buffer))
  	   (input-file-name (buffer-file-name))
  	   (created-at (when (re-search-forward "^created: \\(.+\\)$" nil t)
  			 (match-string 1)))
  	   (updated-at (when (re-search-forward "^updated: \\(.+\\)$" nil t)
  			 (match-string 1)))
  	   (is-zk (sr/is-zettel-name-p input-file-name)))
        (save-buffer)

        (with-temp-buffer
  	(call-process-shell-command sr/pandoc-migration-command input-file-name t)
  	(let ((temp-buffer (current-buffer)))
  	  (with-current-buffer input-buffer
  	    (replace-buffer-contents temp-buffer))))
        (goto-char (point-min))
        (when is-zk
  	(let ((tags))
  	  (while (re-search-forward "#\\([A-z0-9가-힣\\-]+\\)" nil t)
  	    (push (string-replace "-" "_" (match-string 1)) tags)
  	    (let ((start (match-beginning 0))
  		  (end (match-end 0)))
  	      (delete-region start end)
  	      (goto-char start)
  	      (beginning-of-line)
  	      (when (looking-at "^[[:space:]]*$")
  		(delete-line))))
  	  (org-next-visible-heading 1)
  	  (org-set-tags tags)))
        (goto-char (point-min))
        (org-next-visible-heading 1)
        (when created-at
  	(org-set-property "created" created-at))
        (when updated-at
  	(org-set-property "updated" updated-at))

        (if is-zk
  	  (progn
  	    (sr/set-zettel-id-property)
  	    (save-excursion
  	      (replace-regexp "\\[\\[\\([0-9]+\\)]]" "[[id:\\1][\\1]]")))
  	(save-excursion
  	  (replace-regexp "\\[\\[\\(.+?\\)\\]\\]" "\\1")))))
    (message "Done"))
#+end_src
*** Change verbatim to code
Pandoc produces verbatim (=) in place of markdown code (`), but I
prefer to use code (~).
#+begin_src elisp
(defun sr/verbatim-to-code ()
  (interactive)
  (replace-regexp "=" "~"))
(keymap-global-set "C-c m c" 'sr/verbatim-to-code)
#+end_src
** Migration from Obsidian documents
#+begin_src elisp
  (defun sr/migrate-insert-capture-heading ()
    "Insert heading from current buffer's name."
    (interactive)
    (let* ((split (string-split (file-name-base (buffer-name))))
  	 (time (date-to-time (nth 0 split)))
  	 (name (string-join (cdr split) " ")))
      (insert "* " (format-time-string "<%Y-%m-%d> " time) name)))
#+end_src
** Automatic migration
*** Markdown indicator string
I renamed all *.md documents to *.org for easier file searching and
file name resolutions.

To distinguish old markdown documents, I included fixed indicator
strings to them.

#+begin_src elisp
(defconst sr/markdown-indicator-string "###MARKDOWN###"
  "String that indicates the current file is a markdown document.")
#+end_src
*** DWIM migration
#+begin_src elisp
  (defun sr/migrate-dwim ()
    "Migrate current file. DWIM."
    (interactive)
    (save-excursion
      (goto-char (point-min))
      (if (search-forward sr/markdown-indicator-string nil t)
          (progn
  	  (replace-match "" nil t)
  	  (while (search-forward sr/markdown-indicator-string nil t)
  	    (replace-match "" nil t))
  	  (sr/migrate-markdown-to-org))
        (sr/migrate-org-properties)
        (sr/migrate-latex)
        ;; (sr/org-remove-empty-lines-around-headings)
        )
      (message "DWIM migration finished.")))
  (keymap-global-set "C-c m m" 'sr/migrate-dwim)
#+end_src
* Minibuffer
#+begin_src elisp
  (keymap-set minibuffer-mode-map "C-p" #'previous-history-element)
  (keymap-set minibuffer-mode-map "C-n" #'next-history-element)
#+end_src
* Completion
I use default completion system with multiple frontends.
** Vertico (UI, default)
#+begin_src elisp
  (vertico-mode)
#+end_src
*** Multiform
#+begin_src elisp
  (vertico-multiform-mode)
#+end_src
*** Key bindings
#+begin_src elisp
  (keymap-set vertico-map "M-n" #'vertico-next)
  (keymap-set vertico-map "M-p" #'vertico-previous)
  (keymap-set vertico-map "M-TAB" #'vertico-insert)

  (keymap-set vertico-map "C-n" #'next-history-element)
  (keymap-set vertico-map "C-p" #'previous-history-element)
#+end_src
** Marginalia
#+begin_src elisp
  (marginalia-mode)
#+end_src
** Icomplete (UI)
*** Vertical mode
#+begin_src elisp
  (add-hook 'icomplete-mode-hook #'icomplete-vertical-mode)
#+end_src
*** Remap next and previous selection
Remap next and previous selection to =M-n= and =M-p=. I prefer to
maintain the "Emacs rhythm" concept from Mastering Emacs.

Now that I can select items with =M-n=, =M-p=, and =M-TAB=, I can hold
the meta key to maintain the rhythm of pressing keys.

#+begin_src elisp
  (keymap-set
   icomplete-vertical-mode-minibuffer-map
   "M-n" #'icomplete-forward-completions)
  (keymap-set
   icomplete-vertical-mode-minibuffer-map
   "M-p" #'icomplete-backward-completions)

  (keymap-set
   icomplete-vertical-mode-minibuffer-map
   "C-n" #'next-history-element)
  (keymap-set
   icomplete-vertical-mode-minibuffer-map
   "C-p" #'previous-history-element)
#+end_src
*** Override =TAB=
By default, =TAB= key is bound to =minibuffer-complete=. Override it
to use icomplete.
#+begin_src elisp
  (keymap-set icomplete-vertical-mode-minibuffer-map
              "TAB" #'icomplete-force-complete)
#+end_src
*** Unmap space
#+begin_src elisp
  (keymap-unset minibuffer-local-completion-map "SPC")
#+end_src
** List of categories
Non-exhaustive.
- eglot-capf: =eglot-completion-at-point=
- org-heading: [[*Jump to heading][Jump to heading]] and =consult-org-heading=
- info-menu
** Completion styles
[[help:completion-styles-alist]]

#+begin_src elisp
  (setq completion-styles '(basic partial-completion emacs22 orderless))
#+end_src

Category overrides. I cleared the defaults because I want complete
control over my completions.

#+begin_src elisp
  (setq completion-category-defaults nil)

  (setq
   completion-category-overrides
   '((command (styles basic substring partial-completion initials orderless))
     (file (styles partial-completion orderless))
     (eglot-capf (styles basic initials substring orderless))
     (project-file (styles partial-completion substring orderless))
     (xref-location (styles substring))
     (info-menu (styles substring basic))
     (org-heading (styles orderless substring))
     (symbol (styles basic initials substring orderless))
     (kubedoc (styles partial-completion))))
#+end_src
** Testing completion styles
#+begin_src elisp
  (defvar sr/--completion-testing nil)

  (defun sr/completion-test-start (style)
    "Test a completion style STYLE.
    This makes `'completing-read' to only use STYLE as completion style to
    use. call `sr/completion-test-end' when finished."
    (interactive (list (completing-read
                        "Completion style: "
                        (mapcar (lambda (x) (car x)) completion-styles-alist))))
    (when (not sr/--completion-testing)
      (setq sr/--completion-testing t)
      (setq sr/--completion-styles-prev completion-styles)
      (setq sr/--completion-category-overrides-prev completion-category-overrides)
      (setq sr/--completion-category-defaults-prev completion-category-defaults))
    (setq-default completion-styles (list (intern style)))
    (setq-default completion-category-overrides nil)
    (setq-default completion-category-defaults nil))

  (defun sr/completion-test-end ()
    "Revert completion styles altered by `sr/completion-style-start'."
    (interactive)
    (when (not sr/--completion-testing)
      (user-error "Not testing"))
    (setq sr/--completion-testing nil)
    (setq-default completion-styles sr/--completion-styles-prev)
    (setq-default completion-category-overrides sr/--completion-category-overrides-prev)
    (setq-default completion-category-defaults sr/--completion-category-defaults-prev))
#+end_src
** Show current completion category
#+begin_src elisp
  (defun sr/show-completion-category ()
    "Show category in current completion context."
    (interactive)
    (message "%S"
             (completion-metadata-get
              (completion-metadata
               (minibuffer-contents)
               minibuffer-completion-table
               minibuffer-completion-predicate)
              'category)))

  (keymap-set minibuffer-local-map "C-c C-k" #'sr/show-completion-category)
#+end_src
* Software dev
** Current stack
- LSP client: Eglot
- In-buffer completion: Corfu
- Formatting: Format-all
- Diagnostics: Flymake
- Jump to definition: Xref (frontend) and dumb-jump (backend)
- Symbol renaming: Eglot features
- Projects: Projectile
- Tree-sitter
  - Experimenting with Combobulate for structured editing
** Custom mode for shared configurations
Previously, I would set configurations for programming major mode to
=prog-mode=. This was based the assumption that all major modes for
programming languages inherit =prog-mode=.

However, some major modes (e.g. =html-ts-mode=) inherits =text-mode=,
not =prog-mode=, which broke the assumption. The previous workaround
was to redefine those major modes myself but this felt an ad-hoc
solution and was so buggy.

The current solution is to define a minor mode for shared programming
configurations and attaching it to all major modes.

#+begin_src elisp
  (defvar-keymap sr/prog-setup-mode-map
    :doc "Keymap for `sr/prog-setup-mode'.")

  (define-minor-mode sr/prog-setup-mode
    "Minor mode for shared programming setups."
    :lighter "")

  (add-hook 'prog-mode-hook #'sr/prog-setup-mode)
  (add-hook 'html-ts-mode-hook #'sr/prog-setup-mode)
  (add-hook 'yaml-ts-mode-hook #'sr/prog-setup-mode)
#+end_src
** Projectile
[[https://docs.projectile.mx/projectile/index.html][Docs]]

#+begin_src elisp
  (require 'projectile)
  (projectile-mode)
#+end_src

Key bindings
#+begin_src elisp
  (keymap-set projectile-mode-map "C-c p" 'projectile-command-map)
#+end_src
*** Project discovery
[[https://docs.projectile.mx/projectile/usage.html#automated-project-discovery][Docs]]

I recently moved all of my projects into a single directory. I think
this works well when there's no clear boundary between personal and
"work" projects.

~projectile-project-search-path~ is used by the
~projectile-discover-projects-in-directory~ command.
~projectile-auto-discover~ automates calls to the command when using
other Projectile commnads.

#+begin_src elisp
  (setq projectile-project-search-path
        (list sr/dev-project-directory))
#+end_src

Enable automatic discovery on startup. Disable this if you're having
performance issues.

#+begin_src elisp
  (setq projectile-auto-discover t)
#+end_src
** Line numbers
#+begin_src elisp
  (add-hook 'sr/prog-setup-mode-hook #'display-line-numbers-mode)
  (setq display-line-numbers-type 'relative)
#+end_src
** Electric pair mode
Enable them locally
#+begin_src elisp
  (add-hook 'sr/prog-setup-mode-hook #'electric-pair-local-mode)
#+end_src
** Global tab settings
Set tab width.
#+begin_src elisp
  (setq-default tab-width 2)
#+end_src

Disable tabs by default.
#+begin_src elisp
  (setq-default indent-tabs-mode nil)
#+end_src
** LSP: Eglot
*** Key bindings
#+begin_src elisp
  (keymap-set sr/prog-setup-mode-map "C-c C-r" #'eglot-rename)
#+end_src
*** Enabled languages
#+begin_src elisp
  (defvar sr/eglot-ensure-hooks
    '(js-ts-mode-hook
      typescript-ts-mode-hook
      tsx-ts-mode-hook
      html-ts-mode-hook
      c-ts-mode-hook)
    "Hooks to attach `eglot-ensure'.")

  (dolist (hook sr/eglot-ensure-hooks)
    (add-hook hook #'eglot-ensure))
#+end_src
** diagnostics: Flymake
*** Next and previous error
#+begin_src elisp
  (keymap-set flymake-mode-map "M-n" 'flymake-goto-next-error)
  (keymap-set flymake-mode-map "M-p" 'flymake-goto-prev-error)
#+end_src
** Whitespace-mode
#+begin_src elisp
  (add-hook 'sr/prog-setup-mode-hook #'whitespace-mode)
#+end_src
*** Toggle details
#+begin_src elisp
  (defvar sr/whitespace-style-basic
    '(face trailing newline indentation empty missing-newline-at-eof)
    "Value for `whitespace-style', highlighting essential stuff only.")

  (defvar sr/whitespace-style-detailed
    '(face tabs spaces trailing lines space-before-tab newline indentation empty space-after-tab space-mark tab-mark newline-mark missing-newline-at-eof)
    "Value for `whitespace-style' with full details.")

  (setq whitespace-style sr/whitespace-style-basic)

  (setq-default sr/whitespace-use-detailed nil)

  (defun sr/whitespace-toggle-details ()
    "Toggle detailed whitespace visualization."
    (interactive)
    (if (not whitespace-mode)
        (user-error "whitespace-mode not enabled")
      (setq-local sr/whitespace-use-detailed
                  (not sr/whitespace-use-detailed))
      (setq-local whitespace-style
                  (if sr/whitespace-use-detailed
                      sr/whitespace-style-detailed
                    sr/whitespace-style-basic))
                                          ; reload `whitespace-mode'.
      (whitespace-mode -1)
      (whitespace-mode 1)))

  (keymap-set sr/prog-setup-mode-map "C-c C-w" #'sr/whitespace-toggle-details)
#+end_src
*** Display mappings
#+begin_src elisp
  (setq whitespace-display-mappings
        '(
          (space-mark   ?\     [?·]     [?.])
          (space-mark   ?\xA0  [?¤]     [?_])
          (newline-mark ?\n    [?$ ?\n])
          (tab-mark     ?\t    [?» ?\t] [?\\ ?\t])
          ))
#+end_src
** Dumb-jump
*** Xref backend
#+begin_src elisp
  (add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
#+end_src
** Tree-sitter
*** Grammars
I haven't tested all of them.
If you encounter any problems, use the version from the [[https://github.com/mickeynp/combobulate?tab=readme-ov-file#complete-example-with-tree-sitter-grammar-installation][combobulate repository]].

#+begin_src elisp
  (setq treesit-language-source-alist
        '((bash "https://github.com/tree-sitter/tree-sitter-bash")
          (c "https://github.com/tree-sitter/tree-sitter-c")
          (cmake "https://github.com/uyha/tree-sitter-cmake")
          (css "https://github.com/tree-sitter/tree-sitter-css")
          (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
          (elisp "https://github.com/Wilfred/tree-sitter-elisp")
          (go "https://github.com/tree-sitter/tree-sitter-go")
          (html "https://github.com/tree-sitter/tree-sitter-html")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript" "master" "src")
          (json "https://github.com/tree-sitter/tree-sitter-json")
          (make "https://github.com/alemuller/tree-sitter-make")
          (markdown "https://github.com/ikatyang/tree-sitter-markdown")
          (python "https://github.com/tree-sitter/tree-sitter-python")
          (toml "https://github.com/tree-sitter/tree-sitter-toml")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
          (yaml "https://github.com/ikatyang/tree-sitter-yaml" "v0.5.0")))
#+end_src
*** Remaps
#+begin_src elisp
  (add-to-list
   'major-mode-remap-alist
   '(js-json-mode . json-ts-mode))
  (add-to-list
   'major-mode-remap-alist
   '(javascript-mode . js-ts-mode))
#+end_src

#+begin_src elisp
  (defvar sr/tree-sitter-remap-list
    '(c css js json python go typescript yaml)
    "List of tree-sitter remapped languages.
  For each LANG, LANG-mode is remapped to LANG-ts-mode,
  and LANG-ts-mode is used with org mode source codes.")

  (setq major-mode-remap-alist
        (append
         (mapcar
          (lambda (x)
            (let ((pre (symbol-name x)))
              (cons
               (intern (concat pre "-mode"))
               (intern (concat pre "-ts-mode")))))
          sr/tree-sitter-remap-list)
         major-mode-remap-alist))

  (setq org-src-lang-modes
        (append
         (mapcar
          (lambda (x)
            (let ((pre (symbol-name x)))
              (cons
               pre
               (intern (concat pre "-ts")))))
          sr/tree-sitter-remap-list)
         org-src-lang-modes))
#+end_src
** formatting: Format-all
*** Formatters
#+begin_src elisp
  (setq-default format-all-formatters
                '(("CSS" (prettier))
                  ("JavaScript" (prettier))
                  ("TypeScript" (prettier))
                  ("HTML" (prettier))))
#+end_src
*** Key bindings
I use =C-c C-f= by default. But some major modes use =C-c C-f= for
their own functionality. In that case, I use =C-c f= instead.
#+begin_src elisp
  (keymap-set sr/prog-setup-mode-map "C-c C-f" #'format-all-region-or-buffer)
  (keymap-set sr/prog-setup-mode-map "C-c f" #'format-all-region-or-buffer)
#+end_src
** Language-specific configurations
*** CSS
#+begin_src elisp
  (require 'css-mode)
#+end_src
**** Indentation
#+begin_src elisp
  (setq css-indent-offset 2)
#+end_src
**** Rainbow mode
#+begin_src elisp
  (add-hook 'css-ts-mode-hook #'rainbow-mode)
#+end_src
*** C (TS)
#+begin_src elisp
  (require 'c-ts-mode)
#+end_src
**** Indentation
#+begin_src elisp
  (setq c-ts-mode-indent-style 'bsd)
  (setq c-ts-mode-indent-offset 2)
#+end_src
**** Go to the body of the next defun
#+begin_src elisp
  (defun sr/c-previous-defun-body ()
    "Go to body of the previous defun."
    (interactive)
    (if (c-defun-name)
        (c-beginning-of-defun))
    (c-beginning-of-defun)
    (c-syntactic-re-search-forward "{"))

  (defun sr/c-next-defun-body ()
    "Go to body of the next defun."
    (interactive)
    (if (c-defun-name)
        (c-end-of-defun))
    (c-syntactic-re-search-forward "{"))

  (keymap-set c-ts-mode-map "C-M-x" 'sr/c-next-defun-body)
  (keymap-set c-ts-mode-map "C-M-y" 'sr/c-previous-defun-body)
#+end_src
*** Go (TS)
#+begin_src elisp
  (require 'go-ts-mode)
#+end_src
**** Indentation
#+begin_src elisp
  (setq go-ts-mode-indent-offset 2)
#+end_src
**** Gofmt
Normally, format-all is used for code formatting.
But in Go, gofmt is the standard way for doing the job.
#+begin_src elisp
  (keymap-set go-ts-mode-map "C-c C-f" #'gofmt)
#+end_src
*** Dockerfile
#+begin_src elisp
  (add-to-list 'auto-mode-alist
               '("Dockerfile\\'" . dockerfile-ts-mode))
#+end_src
*** JavaScript
#+begin_src elisp
  (require 'js)
#+end_src

#+begin_src elisp
  (setq js-indent-level 2)
#+end_src
*** HTML (TS)
#+begin_src elisp
  (require 'html-ts-mode)
#+end_src

#+begin_src elisp
  (add-to-list 'major-mode-remap-alist '(mhtml-mode . html-ts-mode))
#+end_src
**** Disable SGML mode keymaps
I don't like them
#+begin_src elisp
  (unbind-key "C-c C-f" sgml-mode-map)
#+end_src
**** Use emmet
#+begin_src elisp
  (add-hook 'html-ts-mode-hook #'emmet-mode)
#+end_src
*** Python
indent offset.
#+begin_src elisp
  (setq python-indent-offset 2)
#+end_src
*** Yaml
#+begin_src elisp
  (require 'yaml-ts-mode)
#+end_src

#+begin_src elisp
  (add-to-list 'auto-mode-alist '("\\.yml\\'" . yaml-ts-mode))
#+end_src
** movement: Combobulate
*** Language integration
#+begin_src elisp
  (setq sr/combobulate-enable-hooks
        '(js-ts-mode-hook
          typescript-ts-mode-hook
          tsx-ts-mode-hook
          css-ts-mode-hook
          json-ts-mode-hook
          html-ts-mode-hook
          yaml-ts-mode-hook))

  (dolist (hook sr/combobulate-enable-hooks)
    (add-hook hook #'combobulate-mode))
#+end_src
*** Render navigation tree
#+begin_src elisp
  (defun sr/combobulate-display-tree-at-point ()
    "Render a navigation tree around the node at point."
    (interactive)
    (combobulate-display-draw-node-tree (combobulate-node-at-point)))
#+end_src
** movement: Move by indentation
#+begin_src elisp
  (require 'sr-indentation)
#+end_src
* In-buffer completion
** Stack
I use the default =completion-at-point= with corfu.
** Key bindings
#+begin_src elisp
  (keymap-set sr/prog-setup-mode-map "M-TAB" #'completion-at-point)
#+end_src
** Corfu
*** Enable
#+begin_src elisp
  (add-hook 'sr/prog-setup-mode-hook #'corfu-mode)
  (add-hook 'minibuffer-setup-hook #'corfu-mode)
  (corfu-popupinfo-mode)
#+end_src
*** Display options
#+begin_src elisp
  (setq corfu-cycle t)
  (setq corfu-preview-current nil)
#+end_src
*** Key bindings
#+begin_src elisp
  (keymap-set corfu-map "M-TAB" #'corfu-insert)
#+end_src

Do not complete on =RET=.
#+begin_src elisp
  (keymap-unset corfu-map "RET")
#+end_src
*** Popup info
#+begin_src elisp
  (setq corfu-popupinfo-direction 'vertical)
  (setq corfu-popupinfo-delay '(nil . 0))
  (setq corfu-popupinfo-max-height 20)
#+end_src
*** Autocompletion
#+begin_src elisp
  (setq corfu-auto t)
  (setq corfu-auto-delay 0.1)
  (setq corfu-auto-trigger ".-/")
#+end_src
* English learning
** Open dictionary for word at point
I use Merriam Webster as my dictionary. To foster my learning, I wrote
a simple function to open the word at point in the browser.

I tried using EWW to browse words inside Emacs, but the site feels
broken when rendered in pure HTML. EWW overrides
~browse-url-browser-function~ to ~eww-browse-url~, so to avoid using
EWW, I overrode it.

#+begin_src elisp
  (defcustom sr/eng-dictionary-url
    "https://www.merriam-webster.com/dictionary/%s"
    "Format string for English dictionary.")

  (defun sr/eng-browse-dictionary-at-point ()
    "Look up dictionary for a word at point."
    (interactive)
    (if-let* ((word (word-at-point t))
              (browse-url-browser-function 'browse-url-default-browser)) ; do not use EWW
        (browse-url (url-encode-url (format sr/eng-dictionary-url word)))
      (user-error "No word found at point")))

  (keymap-global-set "C-c d d" #'sr/eng-browse-dictionary-at-point)
#+end_src
* Zettelkasten
I implemented my Zettelkasten in pure Org mode. I tried org-roam
before, but it felt like an overkill for me.
** Constants
#+begin_src elisp
  (defconst sr/zettel-id-format
    "%Y%m%d%H%M"
    "The format for zettel IDs.")

  (defconst sr/zk-backlinks-buffer-name
    "*ZK Backlinks*"
    "Buffer name for displaying ZK backlinks.")
#+end_src
** Zettel file name regex
#+begin_src elisp
  (defconst sr/zettel-file-name-regex
    "zk-.+?\\.org$"
    "Regex for matching zettel file names.")
#+end_src
** ZK Major mode
#+begin_src elisp
  (define-derived-mode sr/zk-mode
    org-mode "Zettelkasten"
    "Major mode for Zettels.")

  (add-to-list 'auto-mode-alist `(,sr/zettel-file-name-regex . sr/zk-mode))
#+end_src
** helper: Goto top level heading
#+begin_src elisp
(defun sr/org-goto-top-level-heading ()
  "Goto upmost heading."
  (interactive)
  (while (org-up-heading-safe) nil))
#+end_src
** Predicate for zettel file names
#+begin_src elisp
  (defun sr/is-zettel-name-p (name)
    "Return t if NAME is a file name to a zettel. else return nill."
    (string-match-p sr/zettel-file-name-regex name))
#+end_src
** Get zettel timestamp
#+begin_src elisp
(defun sr/get-zettel-timestamp ()
  "Get zettel timestamp for current time."
  (format-time-string sr/zettel-id-format))
#+end_src
** Get zettel id for current entry
#+begin_src elisp
  (defun sr/entry-zettel-id ()
    "Return the zettel ID of current entry."
    (save-excursion
      (sr/org-goto-top-level-heading)
      (let ((properties (org-entry-properties (point))))
        (cdr (or (assoc "id" properties)
  	       (assoc "ID" properties))))))

  (defun sr/entry-zettel-id-as-link ()
    "Return the zettel ID of current entry as Org link format."
    (interactive)
    (let ((id (sr/entry-zettel-id)))
      (message id)
      (format "[[id:%s][%s]]" id id)))

  (keymap-set sr/zk-mode-map "C-c z l" (lambda ()
    				       (interactive)
    				       (kill-new (sr/entry-zettel-id-as-link))))
#+end_src

Integrate with Org agenda mode.

#+begin_src elisp
  (defun sr/copy-zettel-link-in-agenda ()
    "Add the zettel link to the kill ring from org-agenda-mode."
    (interactive)
    (let* ((marker (or (org-get-at-bol 'org-marker)
  		                 (org-agenda-error)))
  	       (buffer (marker-buffer marker))
  	       (pos (marker-position marker)))
      (with-current-buffer buffer
        (widen)
        (goto-char pos)
        (kill-new (sr/entry-zettel-id-as-link)))))

  (keymap-set org-agenda-mode-map "C-c z l" 'sr/copy-zettel-link-in-agenda)
#+end_src
** Managing properties
*** Set the ID property
#+begin_src elisp
  (defun sr/set-zettel-id-property ()
    "Set zettel ID of the current entry, if it's not set."
    (interactive)
    (save-excursion
      (sr/org-goto-top-level-heading)
      (unless (org-entry-get (point) "id")
        (org-entry-put (point) "ID" (sr/get-zettel-timestamp)))))
#+end_src
*** Set date properties
#+begin_src elisp
  (defun sr/set-date-properties ()
    "Update the 'updated' property of current buffer as current date.
  Also update the 'created' property if one does not exist."
    (interactive)
    (let ((date-string (format-time-string "%Y-%m-%d" (sr/note-current-date))))
      (save-excursion
        (sr/org-goto-top-level-heading)
        (unless (org-entry-get (point) "created")
  	(org-set-property "created" date-string))
        (org-set-property "updated" (concat "<" date-string ">"))))
    (message "Set date properties"))
#+end_src
*** Set all zettel properties
#+begin_src elisp
(defun sr/set-zettel-properties ()
  "Call `sr/set-date-properties' and `sr/set-zettel-id-property'."
  (interactive)
  (sr/set-date-properties)
  (sr/set-zettel-id-property))
(keymap-global-set "C-c z u" 'sr/set-zettel-properties)
#+end_src
** Backlinks
#+begin_src elisp
  (defun sr/zettel-search-backlinks ()
    "Search for ZK backlinks for current entry."
    (interactive)
    (org-ql-search (org-agenda-files)
      `(regexp ,(sr/entry-zettel-id))
      :title "Backlinks"
      :buffer "*ZK Backlinks*"))

  (keymap-global-set "C-c z b" 'sr/zettel-search-backlinks)
#+end_src
** Registers
Create a custom register type.
#+begin_src elisp
  (cl-defstruct zk-zettel-register
    id)

  (cl-defmethod register--type ((_regval zk-zettel-register)) 'zettel)

  (cl-defmethod register-val-jump-to ((val zk-zettel-register) _arg)
    (org-id-goto (zk-zettel-register-id val)))

  (cl-defmethod register-val-describe ((val zk-zettel-register) _verbose)
    (let* ((id (zk-zettel-register-id val))
           (marker (org-id-find id 'marker))
           (heading (if marker
                        (with-current-buffer (marker-buffer marker)
                          (save-excursion
                            (goto-char marker)
                            (org-get-heading t t t t)))
                      "Entry not found")))
      (princ (format "a zettel: %s (%s)" heading id))))

  (cl-defmethod register-val-insert ((val zk-zettel-register))
    (let ((id (zk-zettel-register-id val)))
      (insert (format "[[id:%s][%s]]" id id))))
#+end_src

Override register command info data. Need to find a better approach
#+begin_src elisp
  (cl-defmethod register-command-info ((_command (eql insert-register)))
    (make-register-preview-info
     :types '(string number zettel)
     :msg "Insert register `%s'"
     :act 'insert
     :smatch t
     :noconfirm (memq register-use-preview '(nil never))))

  (cl-defmethod register-command-info ((_command (eql jump-to-register)))
    (make-register-preview-info
     :types  '(window frame marker kmacro
               file buffer file-query zettel)
     :msg "Jump to register `%s'"
     :act 'jump
     :smatch t
     :noconfirm (memq register-use-preview '(nil never))))
#+end_src

Store current zettel to register, overriding default binding
#+begin_src elisp
  (defun zk-zettel-to-register (register)
    "Store current zettel at point in REGISTER.
  Interactively, prompt for REGISTER using `register-read-with-preview'."
    (interactive (list (register-read-with-preview
                        "Store zettel in register: ")))
    (add-hook 'kill-buffer-hook 'register-swap-out nil t)
    (set-register register (make-zk-zettel-register :id (sr/entry-zettel-id))))

  (keymap-set sr/zk-mode-map "C-x r SPC" #'zk-zettel-to-register)
#+end_src
** Jump to structure note
#+begin_src elisp
  (defun sr/zk-show-structure-note (tag)
    "Show structure note for TAG."
    (interactive (list
  		            (completing-read
  		             "Tag: "
  		             (org-global-tags-completion-table))))
    (when-let* ((result (org-ql-select
  			                  org-agenda-files
  			                  `(tags ,(concat "@" tag))
  			                  :action 'element-with-markers))
  	            (m (plist-get (nth 1 (car result)) :org-marker)))
      (pop-to-buffer-same-window (marker-buffer m))
      (goto-char m)
      (org-fold-show-context 'mark-goto)
      (org-fold-show-subtree)
      (recenter 0)))

  (keymap-global-set "C-c z s" #'sr/zk-show-structure-note)
#+end_src
** Search zettels (Consult)
#+begin_src elisp
  (defun sr/consult-org-heading-zettelkasten ()
    (interactive)
    (consult-org-heading
     nil
     (seq-filter #'sr/is-zettel-name-p (org-agenda-files))))

  (keymap-global-set "C-c j z" #'sr/consult-org-heading-zettelkasten)

  (add-to-list
   'vertico-multiform-commands
   '(sr/consult-org-heading-zettelkasten buffer))

  (consult-customize
   sr/consult-org-heading-zettelkasten
   :group nil)
#+end_src
* VMs
I manage my virtual machines in Mac via UTM. UTM has its command-line
utility named =utmctl=, so I can use it to work with UTM in Emacs.

#+begin_src elisp
  (require 'sr-vm)
#+end_src

** VM list
#+begin_src elisp
  (setq sr/vm-list
        '((
           :name "arm64 Ubuntu"
           :ssh-hostname "vm-ubuntu"
           :utm-name "arm64-ubuntu"
           :poweroff-command "sudo poweroff"
           :sudo-password-file "/Users/kimsaram32/me/secrets/vm-ubuntu-password.txt")
          (
           :name "x64 Debian"
           :ssh-hostname "vm-x64"
           :utm-name "x64-debian"
           :poweroff-command "sudo poweroff"
           :sudo-password-file "/Users/kimsaram32/me/secrets/vm-x64-password.txt")))
#+end_src
** Manual program
#+begin_src elisp
  (defun sr/man-change-program ()
    "Change the program to use in man."
    (interactive)
    (let* ((names (mapcar (lambda (vm) (plist-get vm :name)) sr/vm-list))
           (program-or-name (completing-read "Manual program: " names))
           (is-program (or
                        (string-prefix-p "ssh" program-or-name)
                        (string-prefix-p "man" program-or-name)))
           (command (if is-program
                        program-or-name
                      (format "ssh %s man"
                              (plist-get (seq-find
                                          (lambda (vm)
                                            (equal program-or-name
                                                   (plist-get vm :name)))
                                          sr/vm-list)
                                         :ssh-hostname)))))
      (setq-default manual-program command)
      (message (format (if is-program
                           "Manual program is now `%s'"
                         "Using %s to get manual program")
                       program-or-name))))

  (keymap-global-set "C-c v m" #'sr/man-change-program)
#+end_src
* Consult
** Key bindings
#+begin_src elisp
  (keymap-global-set "C-x b" #'consult-buffer)

  (keymap-global-set "M-g i" #'consult-imenu)
  (keymap-global-set "M-g M-i" #'consult-imenu)
  (keymap-global-set "M-g M-g" #'consult-goto-line)
  (keymap-global-set "M-g g" #'consult-goto-line)

  (keymap-global-set "M-s M-l" #'consult-line)
#+end_src
** Xref
#+begin_src elisp
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)
#+end_src
** Narrowing
#+begin_src elisp
  (setq consult-narrow-key "<")
  (keymap-set consult-narrow-map "?" #'consult-narrow-help)
  (keymap-set consult-narrow-map "C-h" #'consult-narrow-help)
#+end_src
** Clear display-buffer-alist locally
Live preview is messed up with =display-buffer-alist=, so fix it by
temporarily resetting =display-buffer-alist=.
#+begin_src elisp
  (defun sr/consult-fix-display (consultf)
    (let ((preview (funcall consultf)))
      (lambda (action cand)
        (let ((display-buffer-alist nil))
          (funcall preview action cand)))))

  (advice-add 'consult--buffer-preview :around #'sr/consult-fix-display)
  (advice-add 'consult--man-preview :around #'sr/consult-fix-display)
#+end_src
** Jump to Org mode heading
#+begin_src elisp
  (keymap-set org-mode-map "C-c C-j" #'consult-org-heading)
#+end_src

#+begin_src elisp
  (keymap-global-set "C-c j s" #'consult-org-agenda)
#+end_src
* Org mode
** Key bindings
*** Global bindings
#+begin_src elisp
  (keymap-global-set "C-c l" 'org-store-link)
  (keymap-global-set "C-c a" 'org-agenda)
  (keymap-global-set "C-c c" 'org-capture)
#+end_src
*** Move between paragraphs
#+begin_src elisp
  (keymap-set org-mode-map "M-{" 'org-backward-element)
  (keymap-set org-mode-map "M-}" 'org-forward-element)
#+end_src
*** Avoid arrow keys
I don't use a separate keyboard, so arrow keys are hard to press.
Remap arrow key commands to something else.

e.g. =M-<right>= is remapped to =C-c C-==.

#+begin_src elisp
  (keymap-set org-mode-map "C-c C--" #'org-metaup)
  (keymap-set org-mode-map "C-c C-=" #'org-metadown)
  (keymap-set org-mode-map "C-c C-;" #'org-metaleft)
  (keymap-set org-mode-map "C-c C-'" #'org-metaright)
#+end_src
*** Integrate with key repetitions
Those work well with repetitions.

#+begin_src elisp
  (keymap-set org-mode-map "C-c TAB" 'org-cycle)

  (keymap-set org-mode-map "C-c C-x &" 'org-mark-ring-goto)
  (keymap-set org-mode-map "C-c C-x C-o" 'org-open-at-point)
#+end_src
*** Swap footnotes and emphasize mappings
I use footnotes more frequently, and =C-c C-x f= is more harder to
type than =C-c C-x C-f=.
#+begin_src elisp
  (keymap-set org-mode-map "C-c C-x C-f" #'org-footnote-action)
  (keymap-set org-mode-map "C-c C-x f" #'org-emphasize)
#+end_src
** Directories
#+begin_src elisp
  (setq org-directory sr/note-root-directory)
  (setq org-archive-location (expand-file-name
  			                      "archives/%s.archive::"
  			                      sr/note-root-directory))
#+end_src
** File apps
#+begin_src elisp
(add-to-list 'org-file-apps '("\\.md\\'" . emacs))
#+end_src
** Starting hour of a day
- Sync with the core note taking system.
- Also used in org-journal.
#+begin_src elisp
(setq org-extend-today-until sr/note-day-start-hour)
#+end_src
** Startup settings
Use indented headings.
#+begin_src elisp
  (setq org-startup-indented t)
#+end_src

I often have many entries, so it's better to fold them on startup.
#+begin_src elisp
  (setq-default org-startup-folded 'fold)
#+end_src
** Toggle subtree
#+begin_src elisp
  (defun sr/org-toggle-subtree ()
    "Toggle all children of current heading."
    (interactive)
    (if (save-excursion
          (beginning-of-line)
          (outline-invisible-p (line-end-position)))
        (org-fold-show-subtree)
      (org-fold-hide-subtree)))

  (keymap-set org-mode-map "C-c C-x TAB" 'sr/org-toggle-subtree)
  (keymap-set sr/zk-mode-map "TAB" 'sr/org-toggle-subtree)
#+end_src
** Latex
*** LuaLaTeX
#+begin_src elisp
(setq luamagick '(luamagick :programs ("lualatex" "convert")
       :description "pdf > png"
       :message "you need to install lualatex and imagemagick."
       :use-xcolor t
       :image-input-type "pdf"
       :image-output-type "png"
       :image-size-adjust (1.0 . 1.0)
       :latex-compiler ("lualatex -interaction nonstopmode -output-directory %o %f")
       :image-converter ("convert -density %D -trim -antialias %f -quality 100 %O")))
(add-to-list 'org-preview-latex-process-alist luamagick)
#+end_src
*** dvisvgm
Dvisvgm configuration is patched for my environment...
#+begin_src elisp
  (add-to-list 'org-preview-latex-process-alist
  	     '(dvisvgm :programs ("latex" "dvisvgm") :description "dvi > svg"
  		       :message
  		       "you need to install the programs: latex and dvisvgm."
  		       :image-input-type "dvi" :image-output-type "svg"
  		       :image-size-adjust (1.2 . 1.5) :latex-compiler
  		       ("latex -interaction nonstopmode -output-directory %o %f")
  		       :image-converter
  		       ("TEXMFCNF=\"/usr/local/texlive/2025:$TEXMFCNF\" dvisvgm --no-fonts --exact-bbox --scale=%S --output=%O --keep %f")))
#+end_src
*** Use dvisvgm for inline preview
#+begin_src elisp
(setq org-preview-latex-default-process 'dvisvgm)
#+end_src
*** Preview scaling
#+begin_src elisp
(plist-put org-format-latex-options :scale 2)
#+end_src
*** Image location
#+begin_src elisp
  (setq org-preview-latex-image-directory (expand-file-name "ltximg/" sr/note-root-directory))
#+end_src
** New entry blanks
#+begin_src elisp
(setq org-blank-before-new-entry '((heading . auto) (plain-list-item auto)))
#+end_src
** Images
#+begin_src elisp
(setq org-startup-with-inline-images t)
(setq org-image-actual-width nil)
(setq org-image-max-width 400)
#+end_src
** Link abbrevations
#+begin_src elisp
  (setq org-link-abbrev-alist
        `(("zk" . ,(expand-file-name "id:%s" sr/note-root-directory))
  	      ("media" . ,sr/note-media-directory)))
#+end_src
** Lists
#+begin_src elisp
  (keymap-set org-mode-map "C-c C-8" #'org-list-make-subtree)
#+end_src
** Footnotes
Currently, I use footnotes only inside my Zettelkasten. Because the
zettels are created as entries, footnotes for an entry should go
directly below it, not a special heading in the file (which is the
default behavior).
#+begin_src elisp
  (setq org-footnote-section nil)
#+end_src
** Tags
By default, the tag list only includes the tags in the current buffer.
This can be customized to show all tags in agenda files instead.
[[info:org#Setting Tags][org#Setting Tags]]
#+begin_src elisp
  (setq org-complete-tags-always-offer-all-agenda-tags t)
#+end_src

Exprimenting with tag inheritance.
#+begin_src elisp
  (setq org-use-tag-inheritance nil)
#+end_src
** Todo
*** Todo keywords
#+begin_src elisp
  (setq org-todo-keywords
        '((sequence "TODO" "WORKING" "|" "DONE" "FAILED")))
  (setq org-todo-keyword-faces
        '(("TODO" . "gold")
  	      ("IDEA" . "coral")
  	      ("WORKING" . "CadetBlue2")
  	      ("FAILED" . "brown1")))
#+end_src
*** Deadine
#+begin_src elisp
(setq org-deadline-warning-days 21)
#+end_src
*** Priority
#+begin_src elisp
(setq org-priority-lowest 68
	org-priority-highest 65
	org-priority-default 68)
#+end_src
*** Enable habits
#+begin_src elisp
  (add-to-list 'org-modules 'habit)
#+end_src
** Editing source code
#+begin_src elisp
(setq org-edit-src-content-indentation 2)
#+end_src
** Revealing
#+begin_src elisp
  (setq
   org-fold-show-context-detail
   '((isearch . lineage)
     (default . tree)))
#+end_src
** Refiling
- To use =completing-read=, I should set
  =org-outline-path-complete-in-steps= to =nil=.
- Set =org-refile-use-outline-path= to ='file= to use the path of the
  file as a refile target.

#+begin_src elisp
  (setq org-refile-use-outline-path 'file)
  (setq org-outline-path-complete-in-steps nil)
  (setq
   org-refile-targets
   `(((,(expand-file-name "second-brain/projects.org" sr/note-root-directory)
       ,(expand-file-name "second-brain/aor.org" sr/note-root-directory)
       ,(expand-file-name "second-brain/resources.org" sr/note-root-directory)
       ,(expand-file-name "second-brain/archive.org" sr/note-root-directory))
      :maxlevel 1)
     (,(expand-file-name "writings.org" sr/note-root-directory)
      :level 0)))
#+end_src
** Org-id
*** ID format
Used to use timestamp here, but switched to use UUID (default).
ZK links are inserted not by org-id but a custom function.
Other entries should be inserted normal UUIDs to distinguish Zettels.
#+begin_src elisp
  (setq org-id-ts-format sr/zettel-id-format)
  (setq org-id-method 'uuid)
#+end_src
*** Global tracking
#+begin_src elisp
(setq org-id-track-globally t)
#+end_src
*** Do not track archives
#+begin_src elisp
  (setq org-id-search-archives nil)
#+end_src
** Org-agenda
*** Agenda files
#+begin_src elisp
  (setq
   org-agenda-files
   (list sr/note-root-directory
         sr/note-second-brain-directory
  			 (expand-file-name "projects/" sr/note-root-directory)
  			 sr/note-zk-directory))
#+end_src
*** Window setup
#+begin_src elisp
  (setq org-agenda-restore-windows-after-quit t)
#+end_src
*** Display options
Deadline and schedules.
#+begin_src elisp
  (setq org-agenda-todo-ignore-deadlines -1)
  (setq org-agenda-skip-deadline-prewarning-if-scheduled t)
  (setq org-agenda-skip-timestamp-if-deadline-is-shown t)
#+end_src

Sorting strategy.
#+begin_src elisp
  (setq org-agenda-sorting-strategy
        '((agenda habit-up priority-down deadline-up category-keep)
  	(todo urgency-down category-keep)
  	(tags urgency-down category-keep)
  	(search category-keep)))
#+end_src
*** Mode-specific display options
Periodic display options.
#+begin_src elisp
  (setq org-agenda-span 14)
#+end_src

Tag matching display options.
#+begin_src elisp
  (setq org-tags-match-list-sublevels t)
#+end_src
** Org-capture
*** Change finalize shortcut
I need to add tags inside the capture buffer.
#+begin_src elisp
  (keymap-unset org-capture-mode-map "C-c C-c")
  (keymap-set org-capture-mode-map "C-c C-f" 'org-capture-finalize)
#+end_src
** Insert image from clipboard
#+begin_src elisp
  (defun sr/insert-image-from-clipboard ()
    "Prompt for image file name, and create the image in `sr/note-media-directory'.
  Insert the image at point as an Org mode link.

  With a prefix argument, do not insert the link and store it instead."
    (interactive)
    (let ((temp-file-name (make-temp-file "tmp-"))
          image-name)
      (when (not (eq 0 (call-process-shell-command
  		    (format "pngpaste %s" temp-file-name)
  		    nil nil)))
        (user-error "Attempted to paste non-image content"))
      (setq image-name (read-from-minibuffer "image name (with extensions): "))
      (copy-file temp-file-name
                 (expand-file-name image-name sr/note-media-directory))
      (insert (format "[[media:%s]]" image-name))))

  (keymap-set org-mode-map "C-c i" #'sr/insert-image-from-clipboard)
#+end_src
** todo
#+begin_src elisp
  (setf (cdr (assoc 'file org-link-frame-setup)) 'find-file)
#+end_src
* Org QL
#+begin_src elisp
  (defvar sr/org-ql-search-agenda-history nil)

  (defun sr/org-ql-search-agenda (query)
    (interactive (list (read-from-minibuffer
                        "Query: "
                        nil nil nil 'sr/org-ql-search-agenda-history)))
    (org-ql-search (org-agenda-files) query))
#+end_src
* Org-babel
** Key bindings
#+begin_src elisp
  (keymap-set org-babel-map "C-k" #'org-babel-remove-result-one-or-many)
#+end_src
** Load languages
#+begin_src elisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((python . t)
     (shell . t)))
#+end_src
** Disable confirmation
I know what I'm doing
#+begin_src elisp
(setq org-confirm-babel-evaluate nil)
#+end_src
** Make the result keyword lowercased
#+begin_src elisp
(setq org-babel-results-keyword "results")
#+end_src
* Org-journal
:PROPERTIES:
:header-args:elisp: :tangle no
:END:
Currently migrating to manual setup, because I like the DIY approach better.
** Key bindings
Custom lambda functions for opening today's journal file,
since creation of new entries is handled by org-capture.

#+begin_src elisp
  (setq org-journal-prefix-key "C-c j ")
  (keymap-global-set "C-c j j" (lambda ()
  			       (interactive)
  			       (org-journal-new-entry t)))
#+end_src
** Directory and files
#+begin_src elisp
(setq org-journal-dir sr/note-periodic-directory)
(setq org-journal-file-format "%Y/%m/%Y-%m-%d.org")
#+end_src
** Date format
#+begin_src elisp
(setq org-journal-date-format "%Y-%m-%d")
#+end_src
** Time entry format
#+begin_src elisp
(setq org-journal-time-prefix "*** ")
(setq org-journal-time-format "<%R>")
#+end_src
** Opening entries
Use find-file to open journals in current window.
#+begin_src elisp
(setq org-journal-find-file-fn 'find-file)
#+end_src
** Disable carry over
Long-term todo items are already handled by my agenda workflow.
No need for carry overs.
#+begin_src elisp
(setq org-journal-carryover-items "")
#+end_src
* Org-super-agenda
#+begin_src elisp
  (org-super-agenda-mode)
#+end_src
* Org-social
#+begin_src elisp
  (setq org-social-file (expand-file-name "org_social_vfile" user-emacs-directory))
  (setq org-social-relay "https://relay.org-social.org/")
  (setq org-social-my-public-url "https://host.org-social.org/saram/social.org")
#+end_src
* Custom agendas
#+begin_src elisp
  (setq org-agenda-custom-commands nil)
#+end_src
** Daily agenda
#+begin_src elisp
  (add-to-list
   'org-agenda-custom-commands
   '("d" "Daily agenda"
  	 ((agenda ""
  		        ((org-agenda-span 'day)
  		         (org-deadline-past-days 0)
  		         (org-agenda-deadline-faces
  		          '((1.0 . org-scheduled-today)
  		            (0.5 . org-scheduled)
  		            (0.0 . org-scheduled)))
  		         (org-agenda-overriding-header "Events")
  		         (org-super-agenda-groups
  		          '((:name "Events"
  			                 :tag ("event"))
  		            (:discard (:anything))))
  		         (org-agenda-buffer-name "*Org Daily Agenda*")))

  	  (agenda ""
  		        ((org-agenda-span 'day)
  		         (org-agenda-overriding-header "Today")
  		         (org-super-agenda-groups
  		          '((:discard (:tag "event"))
                  (:name "Goals"
                         :tag ("#weekly" "#monthly" "okr"))
  		            (:name "Fleeting notes"
  			                 :and (:tag "fleeting" :not (:todo ("DONE")))
  			                 :order 1)
  		            (:name "School"
  			                 :tag ("schoolwork" "내신"))
                  (:name "Work"
  			                 :tag ("work"))
  		            (:name "Todo"
  			                 :and (:todo ("TODO" "WORKING")
                                     :not (:tag "trivial")))
                  (:name "Trivial tasks"
  			                 :and (:todo ("TODO" "WORKING")
  					                         :tag "trivial"))
                  (:name "ZK"
                         :category "zk")
  		            (:name "Journals"
  			                 :tag "journal"
  			                 :order 2)
  		            (:name "Captures"
  			                 :and (:time-grid t :category "capture")
  			                 :order 2)
                  (:name "Today"
  			                 :time-grid t
  			                 :order 2))))))))
#+end_src
** Project agenda
#+begin_src elisp
  (add-to-list 'org-agenda-custom-commands
  	     '("p" "Projects"
  	       ((tags "current_project"
  		      ((org-agenda-prefix-format '((tags . "- ")))
  		       (org-agenda-overriding-header "Current projects")
  		       (org-agenda-remove-tags t)))
  		(tags "project|current_project"
  		      ((org-agenda-prefix-format '((tags . "- ")))
  		       (org-agenda-overriding-header "All projects")
  		       (org-agenda-remove-tags t))))))
#+end_src
* Capture templates
#+begin_src elisp
  (setq org-capture-templates nil)
#+end_src

Groups
#+begin_src elisp
  (add-to-list 'org-capture-templates '("v" "Capture"))
  (add-to-list 'org-capture-templates '("t" "Todo"))
  (add-to-list 'org-capture-templates '("p" "Problem"))
#+end_src

** Random thoughts (journaling)
#+begin_src elisp
  (defun sr/org-capture-daily-file ()
    "Return the location to a file for daily capturing."
    (sr/file-name-today))

  (add-to-list
   'org-capture-templates
   `("c" "Random thought"
  	 plain (file sr/org-capture-daily-file)
  	 "*** %T %?"))
#+end_src
** Zettelkasten entry
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("z" "Zettel"
  	       entry (file ,(expand-file-name "zk-current.org" sr/note-zk-directory))
  	       "* %?"
  	       :jump-to-captured t))

  (defun sr/org-capture-setup-zettel ()
    "Finish zettel captures."
    (when (equal (plist-get org-capture-current-plist :description) "Zettel")
      (if-let ((id (org-entry-get (point) "ID"))
               (buf (plist-get org-capture-current-plist :buffer)))
        (org-id-add-location id (buffer-file-name buf)))))

  (add-hook 'org-capture-before-finalize-hook #'sr/org-capture-setup-zettel)
#+end_src
** Event
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("e" "Event"
  	       entry (file ,(expand-file-name "captures.org" sr/note-root-directory))
  	       "* %^{title} :event:
  %^{date}t
  %?"
  	       :prepend t
  	       :empty-lines-after 1))
#+end_src
** Todo (Trivial)
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("tt" "Todo (Trivial)"
  	       entry (file ,(expand-file-name "todo.org" sr/note-root-directory))
  	       "* TODO %?"
  	       :prepend t))
#+end_src
** Todo (In a project)
#+begin_src elisp
  (defun sr/todo-project-find-location ()
    (let ((project-file-name
  	 (read-file-name "Project file nasr/ " sr/note-project-directory "" t nil
  			 (lambda (name)
  			   (not (or (backup-file-name-p name)
  				    (auto-save-file-name-p name)))))))
      (unless (string-empty-p project-file-name)
        (find-file
         (expand-file-name project-file-name sr/note-project-directory))
        (goto-char (point-min))
        (unless (search-forward-regexp "^\\* Todo" nil t)
  	(goto-char (point-max))
  	(insert "* Todo")))))

  (add-to-list 'org-capture-templates
  	     `("tp" "Todo (in a project)"
  	       plain (function sr/todo-project-find-location)
  	       "** TODO %?"))
#+end_src
** Project
#+begin_src elisp
  (add-to-list
   'org-capture-templates
   `("x" "Project"
  	 entry (file
            ,(expand-file-name
              "second-brain/projects.org"
              sr/note-root-directory))
  	 (file
      ,(expand-file-name
        "templates/capture-project.org"
        sr/note-root-directory))
  	 :prepend t
     :immediate-finish t
     :jump-to-captured t))
#+end_src
** Problem (Baekjoon)
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("pb" "Baekjoon problem"
  	      entry (file ,(expand-file-name "problems/baekjoon.org" sr/note-root-directory))
  	      "* %t %^{id}. %^{title}
  [[https://www.acmicpc.net/problem/%\\1][Baekjoon]]
  ,** Ideas
  %?"
  	      :jump-to-captured t))
#+end_src
** Problem (Programmers)
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("pp" "Programmers problem"
  	      entry (file ,(expand-file-name "problems/programmers.org" sr/note-root-directory))
  	      "* %t %^{id}. %^{title}
  [[%^{url}][Programmers]]
  ,** Ideas
  %?"
  	      :jump-to-captured t))
#+end_src
** Capture
#+begin_src elisp
  (add-to-list 'org-capture-templates
  	     `("vv" "Capture"
  	       entry (file ,(expand-file-name "captures.org" sr/note-root-directory))
  	       "* %^{title}
  %T
  %?"
  	       :prepend t))
#+end_src
** Capture (elfeed)
#+begin_src elisp
  (add-to-list 'org-capture-templates
    	         `("ve" "Capture (elfeed)"
    	           entry (file ,(expand-file-name "captures.org" sr/note-root-directory))
    	           "* %^{title}
  [[%:external-link][%:title]]
  %?"
    	           :prepend t))
#+end_src
* Help enhancements
** Elisp-demos
#+begin_src elisp
  (require 'elisp-demos)
#+end_src
*** Help
#+begin_src elisp
  (advice-add 'describe-function-1 :after #'elisp-demos-advice-describe-function-1)
#+end_src
*** Helpful
#+begin_src elisp
  (advice-add 'helpful-update :after #'elisp-demos-advice-helpful-update)
#+end_src
** Apropos key bindings
#+begin_src elisp
  (unbind-key "a" help-map)

  (keymap-set help-map "a a" 'apropos-command)
  (keymap-set help-map "a f" 'apropos-function)
  (keymap-set help-map "a v" 'apropos-variable)
  (keymap-set help-map "a u" 'apropos-user-option)
  (keymap-set help-map "a l" 'apropos-library)
#+end_src
** Helpful
#+begin_src elisp
  (require 'helpful)
#+end_src
*** Replace keybindings
#+begin_src elisp
  (keymap-set help-map "f" #'helpful-function)
  (keymap-set help-map "v" #'helpful-variable)
  (keymap-set help-map "k" #'helpful-key)
  (keymap-set help-map "x" #'helpful-command)
  (keymap-set help-map "o" #'helpful-symbol)
#+end_src
* Dired
** Set ls command
#+begin_src elisp
  (setq dired-listing-switches "-hal")
#+end_src
** Omit mode
#+begin_src elisp
  (add-hook 'dired-mode-hook 'dired-omit-mode)
#+end_src
** Delete by moving to trash
#+begin_src elisp
  (setq delete-by-moving-to-trash t)
#+end_src
* Info
** Toggle Linux docs (VMs)
This assumes that the =Info-additional-directory-list= is used
exclusively with it.
#+begin_src elisp
  (defconst sr/info-vm-directory-list
    '("/ssh:vm-ubuntu:/usr/share/info")
    "Additional info directories in VMs.")

  (defun sr/info-toggle-vm-directory ()
    (interactive)
    (if Info-additional-directory-list
        (progn
          (setq Info-additional-directory-list nil)
          (message "Removed VM directories from the list"))
      (setq Info-additional-directory-list sr/info-vm-directory-list)
      (message "Added VM directories to the list")))
#+end_src
* Shr / EWW
** Set max width for readability
#+begin_src elisp
(setq shr-max-width 80)
#+end_src
* Magit
** Org Mode bindings for section
#+begin_src elisp
  (keymap-set magit-section-mode-map "C-c C-u" 'magit-section-up)
  (keymap-set magit-section-mode-map "C-c C-n" 'magit-section-forward)
  (keymap-set magit-section-mode-map "C-c C-p" 'magit-section-backward)
  (keymap-set magit-section-mode-map "C-c C-f" 'magit-section-forward-sibling)
  (keymap-set magit-section-mode-map "C-c C-b" 'magit-section-backward-sibling)
#+end_src
* Rg
#+begin_src elisp
  (keymap-set rg-mode-map "C-n" 'rg-next-file)
  (keymap-set rg-mode-map "C-p" 'rg-prev-file)
  (rg-enable-default-bindings)
#+end_src
* Elfeed
** Key bindings
#+begin_src elisp
  (keymap-global-set "C-c w" 'elfeed)
#+end_src
** Default search filter
#+begin_src elisp
  (setq elfeed-search-filter "+unread")
#+end_src
** EWW Integration
#+begin_src elisp
  (defun sr/elfeed-show-visit-eww ()
    "Visit the current entry with `eww'."
    (interactive)
    (when-let ((link (elfeed-entry-link elfeed-show-entry)))
      (eww link)))

  (keymap-set elfeed-show-mode-map "w" 'sr/elfeed-show-visit-eww)
#+end_src
** Managing 'to read' entries
I often copy my elfeed entries to my iPhone so I can read them while
walking around.

#+begin_src elisp
  (defvar sr/elfeed-to-read-tag 'to-read-list
    "Elfeed tag for 'to read' entries.")
#+end_src

My workflow is as follows: I go through the unread entries, and for
each entry, I hit =a= to add it, and =f= to skip it. When I'm done, I
export the entries to clipboard, paste them to the Notes app, and read
them on my iPhone.

When I come back, I process the entries intoto fleeting notes. Then, I
mark the entries as read.

*** Add current entry to the list with =a=
#+begin_src elisp
  (defun sr/elfeed-show-add-to-read ()
    "Add current entry to 'to read' list and go to the next entry."
    (interactive)
    (when-let ((entry elfeed-show-entry))
      (elfeed-show-tag 'unread sr/elfeed-to-read-tag)
      (message "Addded entry to to-read list")
      (elfeed-show-next)))

  (keymap-set elfeed-show-mode-map "a" 'sr/elfeed-show-add-to-read)
#+end_src
*** Skip current entry with =f=
#+begin_src elisp
  (defun sr/elfeed-show-skip ()
    "Skip the current entry.

  Mark the entry as unread and go to the next entry."
    (interactive)
    (elfeed-show-tag 'unread)
    (elfeed-show-next))

  (keymap-set elfeed-show-mode-map "f" #'sr/elfeed-show-skip)
#+end_src
*** Export the entries with =l= and =e=
Currently, exporting is done by pushing items to the mark ring. I
export the entries just before I leave, so I apply the filter to show
only the entries in the reading list after I come back.

#+begin_src elisp
  (defun sr/elfeed-search-show-to-reads ()
    "Set Elfeed filter to show 'to read' entries only."
    (interactive)
    (elfeed-search-set-filter "+to-read-list"))

  (defun sr/elfeed-export-entries ()
    "Push current entries to the mark ring."
    (interactive)
    (kill-new (string-join
  	     (mapcar
  	      (lambda (entry) (elfeed-entry-link entry))
  	      elfeed-search-entries)
  	     "\n"))
    (message "Pushed current entries to the mark ring."))

  (keymap-set elfeed-search-mode-map "l" 'sr/elfeed-search-show-to-reads)
  (keymap-set elfeed-search-mode-map "e" 'sr/elfeed-export-entries)
#+end_src
** Mark entries as read
In search mode:
#+begin_src elisp
  (defun sr/elfeed-search-read ()
    "Read elfeed entries in search mode."
    (interactive)
    (let ((entries (elfeed-search-selected)))
      (elfeed-untag entries 'unread)
      (elfeed-untag entries sr/elfeed-to-read-tag)
      (mapc #'elfeed-search-update-entry entries)
      (unless (or elfeed-search-remain-on-entry (use-region-p))
        (forward-line))))

  (keymap-set elfeed-search-mode-map "r" #'sr/elfeed-search-read)
#+end_src

In show mode:
#+begin_src elisp
  (defun sr/elfeed-show-read ()
    "Read current elfeed entry."
    (interactive)
    (elfeed-show-untag 'unread 'to-read-list))

  (keymap-set elfeed-show-mode-map "r" #'sr/elfeed-show-read)
#+end_src
** Load entries
#+begin_src elisp
  (defun sr/elfeed-load-entries ()
    "Load entries from elfeed.org."
    (interactive)
    (org-babel-load-file (expand-file-name "emacs/elfeed.org" sr/dotfiles-directory))
    (elfeed-update))

  (sr/elfeed-load-entries)
#+end_src
* Modus-themes
#+begin_src elisp
  (require-theme 'modus-themes)
#+end_src
** Key bindings
#+begin_src elisp
  (keymap-global-set "<f5>" 'modus-themes-rotate)
#+end_src
** Theme
#+begin_src elisp
  (setq modus-themes-common-palette-overrides modus-themes-preset-overrides-faint)
  (modus-themes-load-theme 'modus-vivendi-tinted)
#+end_src
* Spray
#+begin_src elisp
  (keymap-global-set "<f6>" #'spray-mode)
#+end_src
* YaSnippet
#+begin_src elisp
(use-package yasnippet :ensure t)
#+end_src
* Markdown-mode
#+begin_src elisp
  (autoload 'markdown-mode "markdown-mode"
     "Major mode for editing Markdown files" t)
  (add-to-list
   'auto-mode-alist
   '("\\.\\(?:md\\|markdown\\|mkd\\|mdown\\|mkdn\\|mdwn\\)\\'" . markdown-mode))

  (autoload 'gfm-mode "markdown-mode"
     "Major mode for editing GitHub Flavored Markdown files" t)
  (add-to-list 'auto-mode-alist '("README\\.md\\'" . gfm-mode))
#+end_src
* Man
#+begin_src elisp
  (require 'man)
#+end_src
** Disable autocompletion
Override the completion table function =man= command uses.
#+begin_src elisp
  (defun Man-completion-table (str pred flag)
  	'())
#+end_src
* Eglot-booster
#+begin_src elisp
  (eglot-booster-mode)
#+end_src
* Tools
#+begin_src elisp
  (defvar-keymap sr/external-tools-map
    :doc "Keymap for various tools.")

  (keymap-global-set "C-c e" sr/external-tools-map)
#+end_src
** Evil
#+begin_src elisp
  (require 'evil)
#+end_src

I don't enable it by default but it's nice to have
#+begin_src elisp
  (keymap-set sr/external-tools-map "e" #'evil-mode)
#+end_src
** Docker
#+begin_src elisp
  (require 'docker)
#+end_src

Manage Docker in Emacs.
#+begin_src elisp
  (keymap-set sr/external-tools-map "d" #'docker)
#+end_src
** Kubernetes
#+begin_src elisp
  (require 'kele)
#+end_src

=kele-mode= is not enabled by default, because the cluster might be
unreachable at startup. When this is the case, Kele still tries to
connect, causing Emacs to freeze on launch.

#+begin_src elisp
  (keymap-set kele-mode-map "C-c k" kele-command-map)
#+end_src
** Kubedoc
#+begin_src elisp
  (require 'kubedoc)
#+end_src
* Window setup
#+begin_src elisp
  (setq display-buffer-alist nil)
#+end_src
** Org mode source code editing
~org-src-mode~ is a minor mode enabled when editing source code in Org mode.

#+begin_src elisp
  (setq org-src-window-setup 'plain)
  (add-to-list 'display-buffer-alist
  	     `(,(lambda (&rest args) org-src-mode)
  	       (display-buffer-at-bottom)))
#+end_src
** Side window (bottom): Help and occur
#+begin_src elisp
  (add-to-list
   'display-buffer-alist
   `((or
  		(derived-mode help-mode)
      (derived-mode helpful-mode)
  		(derived-mode occur-mode))
  	 (display-buffer-in-side-window)
  	 (side . bottom)
  	 (window-height . 0.4)
  	 (post-command-select-window . t)))
#+end_src
** Side window (right): Info and apropos
#+begin_src elisp
  (add-to-list
   'display-buffer-alist
   `((or
  		(derived-mode Info-mode)
  		(derived-mode apropos-mode))
  	 (display-buffer-reuse-mode-window display-buffer-in-side-window)
  	 (mode . Info-mode)
  	 (side . right)
  	 (window-width . 0.5)
  	 (post-command-select-window . t)))
#+end_src
** Manuals
#+begin_src elisp
  (defconst sr/manual-mode-list
    '(Man-mode kubedoc-mode)
    "List of major modes that function as manuals.")

  (add-to-list
   'display-buffer-alist
   `((or
      ,@(mapcar (lambda (x) (list 'derived-mode x)) sr/manual-mode-list))
     (display-buffer-reuse-mode-window display-buffer-in-side-window)
     (mode . ,sr/manual-mode-list)
     (side . right)
     (window-width . 0.5)
     (post-command-select-window . t)))
#+end_src

Man specific configs.
#+begin_src elisp
  (setq Man-notify-method 'thrifty)

  (add-hook 'Man-mode-hook (lambda ()
  			  (set-window-dedicated-p (selected-window) nil)))
#+end_src
** Zettelkasten
#+begin_src elisp
  (defun sr/in-tab-p (name)
    "Return t if the current tab bar name is NAME."
    (string-equal name
        (if tab-bar-mode
  	  (cdr (assq 'name (tab-bar--current-tab))) "")))

  (add-to-list 'display-buffer-alist
  	     `((derived-mode sr/zk-mode)
  	       (display-buffer-reuse-mode-window display-buffer-in-tab)
  	       (tab-name . "ZK")))

  (add-to-list 'display-buffer-alist
  	     `((and (lambda (&rest args)
  		      (sr/in-tab-p "ZK"))
  		    (mode org-agenda-mode))
  	       (display-buffer-in-side-window)
  	       (side . right)
  	       (slot . 0)
  	       (window-width . 0.4)))
#+end_src
** Elfeed
#+begin_src elisp
  (add-to-list 'display-buffer-alist
  	     `("\\*elfeed-"
  	       (display-buffer-in-tab)
  	       (tab-name . "Elfeed")))
#+end_src
** Tabulated list mode
Major mode for browsing a list of items e.g. Docker mode.

#+begin_src elisp
  (add-to-list
   'display-buffer-alist
   `((derived-mode tabulated-list-mode)
  	 (display-buffer-in-side-window)
  	 (side . bottom)
     (window-height . 0.5)
  	 (post-command-select-window . t)))
#+end_src
